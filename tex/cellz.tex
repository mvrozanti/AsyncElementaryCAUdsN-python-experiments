\documentclass[a4paper]{ltxdoc}
\usepackage{lmodern}			% Usa a fonte Latin Modern			
\usepackage[T1]{fontenc}		% seleção de códigos de fonte.
\usepackage[utf8]{inputenc}		% determina a codificação utiizada (conversão automática dos acentos)
\usepackage{hyperref}  			% controla a formação do índice
\usepackage{parskip}			% espaçamento entre os parágrafos
\usepackage{microtype} 			% para melhorias de justificação
\usepackage{morefloats}			% permite mais floats
\usepackage[absolute]{textpos}
\usepackage{tabularx}
\usepackage[table]{xcolor}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{multirow}

% Babel e ajustes
\usepackage[english,brazil]{babel}		% idiomas
\addto\captionsbrazil{
  %% ajusta nomes padroes do babel
  \renewcommand{\bibname}{Refer\^encias}
  \renewcommand{\indexname}{\'Indice}
  \renewcommand{\listfigurename}{Lista de ilustra\c{c}\~{o}es}
  \renewcommand{\listtablename}{Lista de tabelas}
  %% ajusta nomes usados com a macro \autoref
  \renewcommand{\pageautorefname}{p\'agina}
  \renewcommand{\sectionautorefname}{se{\c c}\~ao}
  \renewcommand{\subsectionautorefname}{subse{\c c}\~ao}
  \renewcommand{\paragraphautorefname}{par\'agrafo}
  \renewcommand{\subsubsectionautorefname}{subse{\c c}\~ao}
  \renewcommand{\paragraphautorefname}{subse{\c c}\~ao}
}  

\usepackage{color}
\definecolor{thered}{rgb}{0.65,0.04,0.07}
\definecolor{thegreen}{rgb}{0.06,0.44,0.08}
\definecolor{thegrey}{gray}{0.5}
\definecolor{theshade}{rgb}{1,1,0.97}
\definecolor{theframe}{gray}{0.6}
\definecolor{blue}{RGB}{41,5,195}
\newcommand{\orientador}{Prof. Dr. Pedro Paulo Balbi de Oliveira}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\IfFileExists{listings.sty}{
  \usepackage{listings}
  \lstset{%
    language=[LaTeX]TeX,
    columns=flexible,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{theshade},
    frame=single,
    tabsize=2,
    rulecolor=\color{theframe},
    title=\lstname,
    escapeinside={\%*}{*)},
    breaklines=true,
    commentstyle=\color{thegrey},
    keywords=[0]{\fichacatalografica,\errata,\folhadeaprovacao,\dedicatoria,\agradecimentos,\epigrafe,\resumo,\siglas,\simbolos,\citacao,\alineas,\subalineas,\incisos},
    keywordstyle=[0]\color{thered},
    keywords=[1]{},
    keywordstyle=[1]\color{thegreen},
    breakatwhitespace=true,
    alsoother={0123456789_},
    inputencoding=utf8,
    extendedchars=true,
    literate={á}{{\'a}}1 {ã}{{\~a}}1 {é}{{\'e}}1 {è}{{\`{e}}}1 {ê}{{\^{e}}}1 {ë}{{\¨{e}}}1 {É}{{\'{E}}}1 {Ê}{{\^{E}}}1 {û}{{\^{u}}}1 {ú}{{\'{u}}}1 {â}{{\^{a}}}1 {à}{{\`{a}}}1 {á}{{\'{a}}}1 {ã}{{\~{a}}}1 {Á}{{\'{A}}}1 {Â}{{\^{A}}}1 {Ã}{{\~{A}}}1 {ç}{{\c{c}}}1 {Ç}{{\c{C}}}1 {õ}{{\~{o}}}1 {ó}{{\'{o}}}1 {ô}{{\^{o}}}1 {Õ}{{\~{O}}}1 {Ó}{{\'{O}}}1 {Ô}{{\^{O}}}1 {î}{{\^{i}}}1 {Î}{{\^{I}}}1 {í}{{\'{i}}}1 {Í}{{\~{Í}}}1,
  }
  \let\verbatim\relax
  \lstnewenvironment{verbatim}[1][]{\lstset{##1}}{}
}

\usepackage[alf]{abntex2cite}	% citacoes

\newcommand{\abnTeXSite}{}

\title{\protect\parbox{\textwidth}{\protect\centering \textbf{\titulo}}}

\author{Marcelo Vironda Rozanti\\\abnTeXSite Felipe Stefanelli de Aguiar Silva\\\abnTeXSite} 

\date{\today}

\hypersetup{
  pdftitle={Conservabilidade de estados de autômatos celulares elementares com atualizações assíncronas por prioridade da vizinhança},
  pdfauthor={Marcelo Vironda Rozanti}{Felipe Stefanelli de Aguiar Silva},
  pdfkeywords={Asynchronous priority based updating, Elementary Cellular Automata, New Kind of Science, Discrete dynamical systems, Number-conserving, Density classification task, Majority problem, Parity problem }, 
  pdfproducer={Marcelo Vironda Rozanti},
  pdfcreator={vim+LaTeX+abnTeX2},
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  urlcolor=blue
}

% \EnableCrossrefs
\CodelineIndex
% \RecordChanges
\hyphenpenalty=1000

\begin{document}

\thispagestyle{empty}
\huge{\centerline{UNIVERSIDADE PRESBITERIANA MACKENZIE}}

\bigskip
\bigskip

\centerline{\large{FACULDADE DE COMPUTAÇÃO E INFORMÁTICA}}

\makeatletter
\vfill
\large{\centering{\@author}}

\vspace*{\fill}

\newcommand{\titulo}{
  \large{\centerline{Três experimentos com atualização assíncrona por prioridade}}
  \large{\centerline{de vizinhança em autômatos celulares elementares}}
}
\titulo

\vspace*{\fill}
\large{\centerline{SÃO PAULO}}
\large{\centerline{2019}}

\pagebreak

\large{\centering{\@author}}
\vfill
\large{\centerline{\@title}}
\vfill
\vspace*{\fill}

Orientador: \orientador
\\
\\
\\


\large{\centerline{SÃO PAULO}}
\large{\centerline{2019}}

\maketitle

\begin{abstract}
  Autômatos Celulares são sistemas computacionais discretos que se têm provado úteis como modelos genéricos de complexidade e representação de diversas dinâmicas em uma variedade de áreas científicas. Estes sistemas podem ser especificados puramente em termos matemáticos e até implementados em estruturas físicas. Muitos deles podem computar funções e resolver problemas algorítmicos. O presente projeto explora um conjunto fundamental deles, chamados Autômatos Celulares Elementares através de um tipo específico de atualização assíncrona, baseada em prioridade da vizinhança, à procura de regras que satisfaçam conservabilidade numérica, problema da maioria ou o problema da paridade. 

  % O código correspondende a este trabalho pode ser acessado no repositório \url{https://github.com/mvrozanti/TCC}.
\end{abstract}
Palavras-chave: Autômatos celulares elementares, Atualização assíncrona por prioridade da vizinhança, New Kind of Science, Sistemas dinâmicos discretos, Conservabilidade numérica, Problema da classificação de densidade, Problema da paridade

\vfill

\selectlanguage{english}
\begin{abstract}
  Cellular Automata are discrete computational systems that have proved useful as general models of complexity and representations of dynamics on a variety of scientific fields. These systems can be specified in purely mathematical terms and be implemented in physical structures. Many of them can compute functions and solve algorithmic problems. The present project attempts to explore a fundamental subset of them, called Elementary Cellular Automata with a specific kind of neighbourhood-priority-based asynchronous updating in the search of either number-conserving, density-classifying or parity-solving rules. 
  %The implementation developed is hosted at \url{https://github.com/mvrozanti/TCC}.
\end{abstract}
Keywords: \@pdfkeywords

\break

\selectlanguage{brazil}
\renewcommand{\contentsname}{\centerline{\Large Sumário}}

\tableofcontents

\listoftables

\listoffigures

\break

\section{INTRODUÇÃO}

\tab Autômatos Celulares (ACs) são uma categoria de sistemas discretos. Por sua própria simplicidade, estes sistemas têm ocupado uma posição privilegiada no estudo de complexidade nos mais diversos campos da ciência, de biologia teórica a economia, entre muitos outros. O desenvolvimento de ACs é tipicamente atribuído a John von Neumann através de suas tentativas de criar um modelo abstrato de autoreprodução biológica. Ao fim de 1950, foi notado que ACs poderiam ser vistos como computadores paralelos \cite[p. 876]{wolfram2002new}. Apesar de falta de investigação científica até 1970, um exemplo de AC se tornou muito famoso por seu comportamento complexo e regras simplesmente descritas inventadas por John Conway, \textit{The Game of Life}, que se popularizou após sua aparição na revista \textit{Scientific American}. 

\tab Desde então, múltiplos estudos compreensivos foram realizados por cientistas ao redor do mundo, destacando os trabalhos feitos por Stephen Wolfram na década de 1980, culminando na publicação do livro A New Kind of Science em que Wolfram apresenta uma coleção de resultados a respeito de ACs, com uma série de descobertas revolucionárias. 

% \tab No capítulo \ref{referencial}, é apresentado alguns conceitos básicos referentes à definição dos ACs. 

\subsection{CONTEXTUALIZAÇÃO E RELEVÂNCIA} \label{contex}

\tab A motivação inicial para o estudo de ACs por parte de von Neumann não era matemática mas tinha como diretriz encontrar uma forma viável de tratar do problema de como fazer máquinas se reproduzirem. Hoje é sabido que esses sistemas são aplicáveis para resolver problemas relativos a classificação de densidade, simulação de partículas, compressão de dados, design estrutural, representação de comportamentos dinâmicos como trânsito em cidades ou movimentação de seres vivos entre muitos outros.

\tab Há uma infinidade de ACs passíveis de construção para modelagem ou solução de problemas. Um deles é a modelagem de tráfego de veículos, como é notado por \citeonline[p. 307]{rosenblueth2011model}:  ``Autômatos Celulares Elementares'', discutidos nos próximos capítulos, ``podem modelar tráfego também. Podemos presumir que um veículo se move para frente ou não dependendo apenas na presença ou ausência de outro veículo em sua frente. Supondo que um veículo se move uma célula para a direita se e apenas se uma a célula à direita está vazia, então a regra 184 corresponde ao tráfego se movendo à direita. Movimento aparente é criado do seguinte modo: se o estado de uma célula é 1 e a de seu vizinho à direita é 0, então esta regra atribui 0 ao estado da célula na próxima geração, eliminando o veículo de sua célula atual (que é representada por 110 e 010). Similarmente, se o estado atual da célula é 0 e de seu vizinho à esquerda é 1, então o próximo estado da célula é 1, aparentemente fazendo o veículo no vizinho da esquerda mover-se uma célula para a direita (cobrindo casos 100 e 101). Deve-se lidar com duas outras situações. Primeiro, um veículo não pode se mover se houver outro veículo diretamente em sua frente (i.e., 111 e 011). Segundo, se não há veículo na célula ou seu vizinho à esquerda, então na próxima geração a célula não terá um veículo também (i.e., 001 e 000)''.

% \tab Já as 

\subsection{OBJETO DE PESQUISA} \label{objetopesq}

\tab O objeto de pesquisa deste trabalho são Autômatos Celulares Elementares (ACEs) com atualização assíncrona por prioridade da vizinhança. 

% O primeiro deles se trata de verificar se a regra 184, que é conservativa em modo síncrono, se mantém conservativa em algum esquema de atualização assíncrono, conforme a definição em de conservabilidade detalhada em \ref{num-conserv}. Considerando que é fato conhecido que nenhum AC síncrono é capaz de classificar densidade perfeitamente, o objetivo do segundo experimento foi verificar se algum ACE poderia adquirir essa capacidade em modo assíncrono.

% \tab Dentre o conjunto de esquemas de atualização não-equivalentes, o objetivo é encontrar quais pares $\langle\,R,E\,\rangle$ são conservativos. Dados os esquemas de atualização mencionados na seção \ref{referencial}, encontrar quais esquemas apresentam conservabilidade numérica.

\tab A implementação do simulador tem como parâmetros as seguintes variáveis:

\begin{itemize}
  \item Largura do reticulado:\\
    \tab É o tamanho do reticulado unidimensional, definido como \textit{n}.
  \item Configuração inicial:\\
    \tab Conjunto ordenado de células do AC, cada uma com um estado definido.
  \item Time steps:\\
    \tab Reticulados resultantes ou iterações da simulação. É a altura das evoluções, para ACEs.
  \item Esquema de prioridades de atualização:\\
    \tab Ordem em que as vizinhanças são atualizadas nas microiterações.
\end{itemize}

Estes conceitos são mais profundamente discutidos no item \ref{referencial}.

\break

\subsection{OBJETIVOS DO ESTUDO} 

\tab O primeiro objetivo trata-se de verificar se a regra 184, que é conservativa em modo síncrono, se mantém conservativa em algum esquema de atualização assíncrono, conforme a definição em de conservabilidade detalhada em \ref{num-conserv}. 

\tab Considerando que é fato conhecido que nenhum AC síncrono é capaz de classificar densidade perfeitamente, o objetivo do segundo experimento foi verificar se algum ACE poderia adquirir essa capacidade em modo assíncrono.

\tab É também um fato conhecido que o problema da paridade, detalhado em \ref{parity-problem}, não pode ser resolvido por ACEs de raio menor ou igual a dois executados em modo síncrono. O objetivo do terceiro experimento foi verificar se ACEs de raio um executados com a estratégia descrita em \ref{tiposatt} seriam capazes de resolver este problema.

\begin{itemize}
  \item Definição formal da estratégia de atualização;
  \item Definição e identificação da propridade e problemas estudados;
  \item Renderização das evoluções temporais.
  % \item Otimização da pesquisa via filtragem de esquemas equivalentes independentes.
\end{itemize}

\subsection{JUSTIFICATIVA}
\tab A motivação para o presente trabalho é estudar três importantes propriedades nos ACEs executados com a estratégia definida em \ref{tiposatt}: 

\begin{itemize}
  \item Conservabilidade numérica;
  \item Capacidade de classificação de densidade;
  \item Capacidade de resolver o problema da paridade.
\end{itemize}

\subsubsection{Experimento 1}

\tab É sabido que há cinco regras que apresentam conservabilidade numérica em suas evoluções: 170, 184, 204, 226 e 240. A motivação para o primeiro experimento foi descobrir se, no esquema de atualização usado, essa propriedade é mantida para a regra 184 (que é equivalente à regra 226), que foi escolhida por ser a mais rica do ponto de vista dinâmico dentre as cinco, empatada com a 226.

\break

\subsubsection{Experimentos 2 e 3}

\tab A motivação para os dois últimos experimentos a respeito do problema da maioria e problema da paridade é estudar que se os ACEs com atualização assíncrona por prioridade eram capazes de resolver esses problemas de decisão emblemáticos no contexto de ACs.

\subsection{ORGANIZAÇÃO E DELIMITAÇÃO DO ESTUDO} \label{delimitacao}

\tab A pesquisa se limita a ACEs com o tipo de atualização evidenciado no item \ref{ref_ace}, com largura de reticulados testados até \textit{n}=15 e com \textit{r}=1. Para o primeiro experimento, foram testados esquemas de atualização \textit{independentes} para o ACE 184, i.e., os esquemas cujas dinâmicas são definidas pelas transições \textit{ativas} de estado da regra, as que mudam o estado da célula central. No segundo e no terceiro experimento foram selecionadas regras \textit{balanceadas} (as que têm quatro transições de estado para cada um dos estados, 0 e 1) que tivessem no máximo 75 esquemas independentes por regra; o balanceamento se deve a uma condição necessária do problema e a restrição em 75 esquemas para diminuir as demandas computacionais.Cada esquema contém a prioridade de cada uma das 8 vizinhanças possíveis do espaço elementar, correspondendo às vizinhanças, respectivamente: (111, 110, 101, 100, 011, 010, 001, 000).  Em cada esquema, o número 1 indica que a vizinhança será a primeira a ser atualizada (ou seja, máxima prioridade), o número 2 indica que a vizinhança será a segunda a ser atualizada, e assim por diante. 

% \subsection{ORGANIZAÇÃO DO ESTUDO}

Descrição dos capítulos:

\begin{enumerate}
  \item Introdução
    \subitem Preâmbulo deste trabalho.
  \item Referencial Teórico
    \subitem Sustentação argumentativa sobre o tema proposto.
  \item Metodologia de Pesquisa
    \subitem Sistematização dos instrumentos e processos de estudo empregados no presente trabalho.
  \item Resultados dos Experimentos
    \subitem Análise e apresentação dos resultados das evoluções propostas.
  \item Cronograma
    \subitem Planejamento das tarefas necessárias para a conclusão deste trabalho, bem como suas expectativas de início e conclusão.
\end{enumerate}

\section{REFERENCIAL TEÓRICO} \label{referencial}
\tab Em relação ao referencial teórico estudado neste TCC, foi de suma importância entender os seguintes tópicos:

\subsection{AUTÔMATOS CELULARES ELEMENTARES} \label{ref_ace}

\tab Um AC pode ser descrito simplesmente por seu \textit{reticulado} e sua \textit{regra de transição}. O reticulado é um conjunto finito \textit{d-dimensional} ordenado de células onde cada célula no índice \textbf{i} tem um estado entre \textit{k} estados. As regras de transição definem o novo estado de uma determinada célula em função de sua vizinhança de tamanho \textit{2r+1}, sendo \textit{r} raio do AC. O comportamento da aplicação das regras de transição nas bordas do espaço pode ser especificado de várias formas, muitas vezes como conexo com a borda oposta, tornando o espaço efetivamente contínuo. 

\tab Uma definição direta das regras de transição consiste na enumeração de todos os estados possíveis da própria célula, das células vizinhas e do próximo estado, contendo a informação necessária para computar o estado futuro das células em função de sua vizinhança e, consequentemente, da evolução como um todo. A regra do AC corresponde a função local, formada por transições de estado. A ação dela sobre cada célula de uma configuração pode ser vista como resultado da ação de uma função global sobre o reticulado, que é distinta da função local.

\begin{figure}[!htbp]
  \centerline{\includegraphics[width=10cm]{imgs/rule_22.png}}
  \caption{Ilustração das regras de transição para a regra 22 no código Wolfram. }
\end{figure}

\tab ACEs formam a família de ACs com \textit{d}=1, \textit{k}=2 e \textit{r}=1, ou seja, são unidimensionais, com células binárias e vizinhanças definidas como 3 células contíguas. O reticulado é dito ter largura \textit{n}, isto é, tem \textit{n} células em cada reticulado da evolução e permanece constante até o fim das evoluções.

\tab Os ACEs são enumerados por suas regras de transição, de 0 a 255, o que é conhecido como número de Wolfram. Segundo \citeonline[p. 24]{wolfram2002new}, ``A linha superior em cada caixa dá uma das possíveis combinações de cores para uma célula e sua vizinhança imediata. A linha inferior então especifica qual será a cor da célula central no próximo passo em cada um desses casos.''

\tab Uma definição direta de regra de transição consiste na enumeração de todas as combinações de estado possíveis da vizinhança de uma célula, e do próximo estado associado a elas, o que define a função local a ser usada na evolução temporal do reticulado.

% \begin{figure}[!htbp]
%   \centerline{\includegraphics[width=8cm]{imgs/ElementaryCA.png}}
%   \caption{Ilustração das 256 regras elementares. }
% \end{figure}
% \break

\subsection{ATUALIZAÇÃO ASSÍNCRONA \\POR PRIORIDADE DA VIZINHANÇA} \label{tiposatt}
\tab Parte imprescindível da definição de um AC é a ordem de atualização das células no reticulado. Apesar de os ACs serem fundamentalmente concebidos com o comportamento de atualização síncrona, é possível se utilizar das mais diversas e criativas estratégias de atualização.

\tab No presente trabalho foi empregado uma nova estratégia de atualização: por "prioridade da vizinhança", em que os esquemas associados contém a prioridade da atualização de cada uma das 8 possíveis vizinhanças do espaço elementar, as quais deverão ser seguidas deterministicamente durante as evoluções temporais.  

\tab Esse tipo de atualização requer uma distinção das iterações globais e locais (microiterações):  as prioridades de vizinhanças são iteradas sequencialmente de menor a maior e para cada prioridade, o reticulado é varrido e atualizam-se apenas as células que tenham vizinhança com a prioridade atual, mantendo-se o estado das vizinhanças que não estejam na prioridade atual da iteração. Ao fim da varredura do reticulado, o processo se repete para a próxima prioridade, agora iterando sobre o reticulado gerado no processo descrito anteriormente, com uma prioridade menor. O reticulado resultante após iterar sobre todas as prioridades é chamado de iteração global (ou macroiteração) e é incluído nas renderizações, o que não acontece com as microiterações.

\tab Esse modo de atualização inclui também a atualização síncrona, que pode ser simulada quando as prioridades do esquema têm mesmo valor (11111111, 22222222, ..., etc). As evoluções podem ser identificadas como um par $\langle\,R,E\,\rangle$, onde \textit{R} é a regra e \textit{E} é um esquema de prioridade. 

\tab É importante notar que diferentes esquemas de prioridade podem ser equivalentes: quando esquemas de prioridade equivalentes são aplicados a uma mesma regra, são geradas evoluções iguais. Um exemplo entre esquemas equivalentes pode ser entre os esquemas 11111112 e 11111113, em que as prioridades da última transição são aparentemente diferentes, mas efetivamente iguais. Outro caso é a equivalência entre os oito esquemas síncronos: 11111111, 22222222, 33333333, etc. Para experimentos feitos neste trabalho, foram filtrados esses dois casos, de modo que não houvesse redundância nas execuções, reduzindo o custo computacional.

\tab Além desses dois tipos de equivalência entre esquemas, é possível haver equivalência entre esquemas apenas quando são pareados a uma determinada regra, em função de suas transições não-ativas, como é o caso do que acontece no primeiro experimento, discutido no capítulo \ref{resultados}.

% No presente trabalho, são filtrados os esquemas simetricamente equivalentes, isto é, os esquemas semi-totalísticos: ``Regras totalísticas dependem apenas do número total de células pretas em uma vizinhança; regras semi-totalísticas [...] também dependem da cor da célula central'' de acordo com \citeonline{wolfram2002new}.

% \break 
\subsection{CONSERVABILIDADE NUMÉRICA} \label{num-conserv}
\tab Segundo \citeonline{boccara2002number}, ``Uma regra de AC \textit{f} de \textit{q} estados, unidimensional, de largura \textit{n} é conservativa se, para todas as configurações cíclicas de tamanho \textit{L} \(\geq\) \textit{n} satisfaz'':

\[f(x_1,x_2,...,x_{n-1},x_n) + f(x_2,x_3,...,x_n,x_{n+1}) + ... \]
\tab \[ + \;   f(x_L,x_1,...,x_{n-2},x_{n-1} = x_1 + x_2 + ... + x_L\] 

% \break

\tab No contexto de ACEs, uma evolução é dita conservativa caso, para qualquer configuração inicial, a quantidade de um determinado estado é sempre a mesma para todas as iterações. Como é mencionado no item \ref{contex}, ACs conservativos podem ser usados para modelar ambientes em que há conservabilidade, como trânsito automobilístico, simulação de partículas, entre outros. A regra 184 é uma regra que, com execução síncrona e (como este trabalho apresenta) assíncrona, gera evoluções conservativas pela definição anterior de conservabilidade.

\subsection{CLASSIFICAÇÃO DE DENSIDADE} \label{dct}
\tab Segundo \citeonline[p. 1]{capcarrere1996two}, ``um exemplo dessa computação emergente é utilizar um AC para determinar a densidade global de bits em uma configuração de estado inicial. Conhecido como o problema de classificação de densidade, o AC unidimensional de dois estados é apresentado com uma configuração inicial arbitrária e deve convergir no tempo para um estado de apenas 1s se a configuração inicial contiver uma densidade de 1s > 0,5, e de apenas 0s se essa densidade < 0,5; para uma densidade inicial de 0,5, o comportamento do AC é indefinido''. Em outras palavras, capacidade de classificação de densidade se dá quando o reticulado cíclico de um ACE torna-se totalmente preenchido pelo estado predominante na configuração inicial.

\subsection{PROBLEMA DA PARIDADE} \label{parity-problem}
\tab Segundo \citeonline[p. 1]{betel2012parity}, ``Consideramos o problema de paridade em autômatos celulares unidimensionais, binários e circulares: se a configuração inicial contém um número ímpar de 1s, a reticulado inteira deve convergir para 1s; caso contrário, deve convergir para 0s''. Assim como o problema da maioria, ``é fácil ver que o problema é mal-definido para reticulados de tamanho ímpar (que, por definição, nunca seriam capazes de convergir para 1)''. É possível entender, então, que a solução do problema da paridade se dá quando o reticulado cíclico de um ACE torna-se totalmente preenchido pelo estado de quantidade (necessariamente) ímpar na configuração inicial.  

\section{METODOLOGIA DA PESQUISA}
\tab No que tange à Metodologia empregada neste TCC, o trabalho teve início com uma revisão da literatura específica sobre o tema da pesquisa. Esta pesquisa abrange conceitos fundamentais de teoria da computação e o ``estado da arte'' em termos de análise de conservabilidade.

\tab Este alicerce teórico foi obtido através de autores como: Wolfram; Boccara;
entre outros, além de pesquisas em periódicos científicos, sites, publicações em empresas, teses e dissertações em universidades e publicações de associações técnicas.  A leitura, análise e comparação da fundamentação teórica tiveram início com ACEs síncronos, modificados em seguida para viabilizar o tipo de atualização mencionado no item \ref{tiposatt}.

\tab Os três experimentos foram de natureza computacional. Foram testados comprimentos de reticulado (\textit{n}) sucessivamente maiores, de \textit{n}=5 em diante. Para o primeiro experimento, foram testados esquemas de atualização \textit{independentes} para o ACE 184, i.e., os esquemas cujas dinâmicas são definidas pelas transições \textit{ativas} de estado da regra, as que mudam o estado da célula central. Para o segundo experimento, foram escolhidas regras \textit{balanceadas} (as que têm quatro transições de estado para cada um dos estados, 0 e 1) e que tivessem no máximo 75 esquemas independentes por regra; o balanceamento se deve a uma condição necessária do problema e a restrição em 75 esquemas para diminuir as demandas computacionais.

\tab A capacidade de classificação de densidade e a capacidade de resolução do problema da paridade foram medidas através da contagem de configurações iniciais em que cada par $\langle\,R,E\,\rangle$ resolve o problema em questão.

\subsection{ETAPAS DA PESQUISA}
\tab Para definir as etapas da pesquisa, foi necessário examinar as delimitações de estudo (item \ref{delimitacao}), desenvolvendo uma implementação que atendesse à execução dos ACE com esquemas de atualização por prioridade de vizinhança, como descrito no Cronograma apresentado no item \ref{cron}. No decorrer da fundamentação teórica foram realizados três experimentos. 

% \tab Os 4683 esquemas de atualização mencionados no item \ref{ref_ace} foram testados primeiramente contra a regra 184, que é conservativa em modo síncrono.
% A extensão de evoluções celulares se limitou a n=15, como é explicitado no item \ref{delimitacao}.

% \break

Assim, pode-se dizer que as etapas desenvolvidas neste estudo foram:

\begin{enumerate}
  \item Revisão bibliográfica;
  \item Fundamentação teórica;
  \item Desenvolvimento e implementação em Python dos ACEs discutidos;
  \item Execução dos experimentos;
  \item Análise das execuções;
  \item Conclusão e documentação final da pesquisa.
\end{enumerate}

\subsection{CLASSIFICAÇÃO DA PESQUISA}
\tab O tempo total previsto para a conclusão desta pesquisa é de 1 ano, como mostrado no capítulo \ref{cron}.

\tab Esta é uma pesquisa exploratória, dada a natureza desconhecida das propriedades de ACEs com o tipo de atualização mencionado em \ref{ref_ace}. Baseada em medidas objetivas e dados verificáveis, esta pesquisa foi voltada para encontrar caminhos, formas, maneiras e procedimentos para atingir um determinado fim, buscando definir um processo ou uma ferramenta que leve à solução do problema proposto.  Quanto aos meios, foram utilizados os recursos mencionados na Bibliografia.

\break

\section{RESULTADOS DOS EXPERIMENTOS} \label{resultados}

\textbf{Experimento 1}

% A simulação da regra 184 para todos os esquemas de prioridade não-equivalentes até largura \textit{n}=15 mostra em quais esquemas a regra permanece conservativa:
\tab Em relação à conservabilidade, a execução da regra 184 com todas as configurações iniciais de comprimento até \textit{n}=15, e com todos os seus esquemas de prioridade independentes, resultou num conjunto de esquemas assíncronos em que a regra permanece conservativa, como é mostrado na figura \ref{fig:evolucoes}. Nota-se, entretanto, que todos correspondem ao modo síncrono, já que eles só diferem entre si nas prioridades das transições inativas, e as prioridades das ativas são as mesmas em cada esquema.

\begin{figure}[h]
  \begin{minipage}[htb]{.4\linewidth}
    \centering
    \fbox{\includegraphics[width=0.1\linewidth]{imgs/184-5x33-11111111.png}}
    \caption{Todos os esquemas assíncronos conservativos da regra 184 são equivalentes.}
    \label{fig:evolucoes}
    % \rule{6cm}{6cm} %to simulate an actual figure
  \end{minipage}%
  \begin{minipage}[htb]{.6\linewidth}
    \centering
    \begin{tabular}{ | c | c | } \hline
      Regra & Esquema  \\\hline 
      \multirow{13}{*}{184} 
	    & \underline{3}222\underline{2}2\underline{21} \\
	    & \underline{3}111\underline{1}1\underline{12} \\      
	    & \underline{2}333\underline{3}3\underline{31} \\      
	    & \underline{2}111\underline{1}1\underline{13} \\      
	    & \underline{1}333\underline{3}3\underline{32} \\      
	    & \underline{1}222\underline{2}2\underline{23} \\      
	    & \underline{2}222\underline{2}2\underline{21} \\      
	    & \underline{2}111\underline{1}1\underline{12} \\      
	    & \underline{2}111\underline{1}1\underline{11} \\      
	    & \underline{1}222\underline{2}2\underline{22} \\      
	    & \underline{1}222\underline{2}2\underline{21} \\      
	    & \underline{1}111\underline{1}1\underline{12} \\      
	    & \underline{1}111\underline{1}1\underline{11} \\       
      \hline
    \end{tabular}
\end{minipage}
\label{fig:test}
\end{figure}

\tab As prioridades com underscore significam que qualquer prioridade pode ser colocada em seu lugar. Isto se deve a, nesses índices, as transições de estado serem não-ativas e, portanto, serem irrelevantes em que ordem são atualizadas.
No entanto, é possível ver que as prioridades das transições de estado ativas são iguais entre si, que são todas representações equivalentes da execução síncrona.

\textbf{Experimentos 2 e 3}

\tab Em relação à capacidade de classificação de densidade, a execução das regras e esquemas de prioridade independentes selecionadas até comprimento \textit{n}=7 bastou para mostrar que nenhuma das regras elementares testadas foi capaz de classificar a densidade nem resolver o problema da paridade totalmente, qualquer que fosse o esquema de atualização independente utilizado.

\break

\section{CRONOGRAMA} \label{cron}

\tab As atividades desta pesquisa se desenvolveram de acordo com o cronograma apresentado a seguir, no prazo de 12 meses:

\newcommand{\ccy}{\cellcolor{yellow}}
\begin{table}[h]
  \caption{Cronograma de atividades}
  \centerline{
    \begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|} \hline
      \multirow{2}{*}{ATIVIDADE}                & \multicolumn{12}{|c|}{MÊS}     						    \\
				                & 1    & 2    & 3    & 4    & 5    & 6    & 7    & 8    & 9    & 10   & 11   & 12   \\\hline
      Revisão bibliográfica                             
						& \ccy & \ccy &      &      &      &      &      & \ccy &      & \ccy & \ccy &      \\\hline
      Fundamentação teórica                             
						&      & \ccy & \ccy &      &      &      &      &      &      &      &      &      \\\hline
      Desenvolvimento e implementação em Python         
						&      & \ccy & \ccy &      &      &      &      &      &      &      &      &      \\\hline
      Conclusão e documentação final da pesquisa        
						&      &      &      & \ccy & \ccy &      &      &      &      &      &      &      \\\hline
      Experimento 1                        
						&      &      &      & \ccy & \ccy &      &      &      &      &      &      &      \\\hline
      Experimento 2                      
						&      &      &      &      &      & \ccy & \ccy &      &      &      &      &      \\\hline
      Experimento 3                      
						&      &      &      &      &      &      &      &      &      & \ccy & \ccy &      \\\hline
      Análise e validação dos experimentos                            
						&      &      &      &      &      & \ccy & \ccy &      &      &      & \ccy &      \\\hline
      Conclusão e documentação final da pesquisa        
						&      &      &      &      &      &      &      & \ccy & \ccy & \ccy & \ccy & \ccy \\\hline
    \end{tabular}
  }
\end{table}

% \break

\addcontentsline{toc}{section}{Referências}
\bibliography{cellz} \label{bib}

\end{document}
